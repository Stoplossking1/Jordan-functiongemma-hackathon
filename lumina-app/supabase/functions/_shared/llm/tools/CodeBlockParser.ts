function wrapFence(name: string): [string, string] {
  return [`<${name}>`, `</${name}>`];
}

export const LANG_SQL = 'sql';
export const LANG_TYPESCRIPT = 'typescript';
export const LANG_YAML = 'yaml';
export const LANG_JSON = 'json';

export const CODE_FENCE_DEFAULT: [string, string] = ['```', '```'];
export const CODE_FENCE_4_TICKS: [string, string] = ['````', '````'];
export const CODE_FENCES_XML: [string, string][] = [
  wrapFence('source'),
  wrapFence('code'),
  wrapFence('pre'),
  wrapFence('codeblock'),
  wrapFence('sourcecode'),
];

// Check for shell code blocks
export const SHELLS = ['bash', 'sh', 'shell', 'cmd', 'batch', 'powershell', 'ps1', 'zsh', 'fish', 'ksh', 'csh', 'tcsh'];

export function getShellNameIfBlock(lineRaw: string): string | undefined {
  const line = lineRaw.trim();
  // shell blocks look like this
  // ```bash
  const prefix = CODE_FENCE_DEFAULT[0];
  if (line.startsWith(prefix)) {
    const pos = prefix.length;
    for (const shell of SHELLS) {
      if (line.startsWith(shell, pos)) {
        return shell;
      }
    }
  }
  return undefined;
}

export const CODE_FENCES: [string, string][] = [CODE_FENCE_DEFAULT, CODE_FENCE_4_TICKS, ...CODE_FENCES_XML];

// if we want to look for 3 or 4 backticks, we need to check for 4 backticks first
// - since 3 are always included in 4 we would otherwise always match the 3 tick version
export const CODE_FENCES_SORTED_FOR_SUBSTRINGS: [string, string][] = [
  CODE_FENCE_4_TICKS, // Four backticks first
  CODE_FENCE_DEFAULT, // Three backticks second since it's a sub-string of the 4 tick version
  ...CODE_FENCES_XML,
];

export function isMarkdownFence(fence: string): boolean {
  return fence.startsWith('`');
}

export function isXmlFence(fence: string): boolean {
  return fence.startsWith('<');
}

export function chooseFence(fileContents: string[]): [string, string] {
  // Find a fence that's not used in the content
  for (const [open, close] of CODE_FENCES) {
    const newlineOpen = '\n' + open;
    const newlineClose = '\n' + close;
    let foundConflict = false;
    for (const fileContent of fileContents) {
      // check that the open or closing fence is not at the beginning of a line
      // we handle the special case of the first line separately
      if (
        fileContent.startsWith(open) ||
        fileContent.startsWith(close) ||
        fileContent.includes(newlineOpen) ||
        fileContent.includes(newlineClose)
      ) {
        foundConflict = true;
        break;
      }
    }

    if (foundConflict) {
      continue;
    }

    return [open, close];
  }

  console.warn(
    `Unable to find a fencing strategy! Falling back to: ${CODE_FENCE_DEFAULT[0]}...${CODE_FENCE_DEFAULT[1]}`,
  );
  return CODE_FENCE_DEFAULT;
}

export function formatAsCodeblock(
  content: string,
  fence: [string, string],
  language?: string,
  filenamePath?: string,
  isReadonly?: boolean
): string {
  const isMarkdown = isMarkdownFence(fence[0]);
  // language identifier can only be shown in markdown style
  const lang = language && isMarkdown ? language : '';
  const filenameLine = filenamePath ? `${filenamePath}${isReadonly ? ' (readonly)' : ''}\n` : '';
  // only add the additional linebreak at the end of the code if there's none already
  // otherwise when parsing it back we might add additional linebreaks
  const lineBreakIfNeeded = isMarkdown && !content.endsWith('\n') ? '\n' : '';
  return `${filenameLine}${fence[0]}${lang}\n${content}${lineBreakIfNeeded}${fence[1]}`;
}

// Helper function to check if a substring matches at a specific position
function matchesAt(text: string, position: number, pattern: string, wantFullMatch: boolean): boolean {
  // Check if we have enough characters
  if (position + pattern.length > text.length) return false;

  // Compare directly with the portion of the string
  for (let i = 0; i < pattern.length; i++) {
    if (text[position + i] !== pattern[i]) return false;
  }

  return wantFullMatch ? pattern.length === text.length - position : true;
}

// block: filename was preceeding a markdown block
// saw: filename was mentioned in the content generated by the LLM
// chat: the filename was the only one provided as input to the LLM (e.g. "change <filename>")
export type FilePathSource = 'block' | 'saw' | 'chat';

// Create an array with all sources, from most reliable to least reliable
export const ALL_FILE_PATH_SOURCES: FilePathSource[] = ['block', 'saw', 'chat'];

export type CodeBlockParserCallback<T = void> = (
  content: string,
  isCode: boolean,
  lang: string | undefined,
  properlyTerminated: boolean,
) => T;

export class CodeBlockParser<T = void> {
  activeFence?: [string, string];
  lang?: string;
  content = '';
  lineBuffer = '';
  isLineStart = true;
  leadingSpaces = 0;
  private results: T[] = [];
  private codeBlocksFound = 0;

  constructor(private callback: CodeBlockParserCallback<T>) {}

  // Helper function to reset state and trigger callback
  flushBlock(isCode: boolean, isComplete: boolean): T | undefined {
    const tempContent = this.content;
    const tempLang = this.lang;

    // Reset state first to avoid issues with callbacks
    this.activeFence = undefined;
    this.lang = undefined;
    this.content = '';

    // Trigger callback
    if (isCode || tempContent) {
      // don't send empty non-code block
      const result = this.callback(tempContent, isCode, tempLang, isComplete);
      if (result !== undefined) {
        this.results.push(result);
      }
      if (isCode) this.codeBlocksFound++;

      return result;
    }
    return undefined;
  }

  // Get all the results
  getResults(): T[] {
    return this.results;
  }

  getCodeBlocksCount(): number {
    return this.codeBlocksFound;
  }

  processLine(line: string, leadingSpaces: number, isLastLine = false) {
    if (!this.activeFence) {
      // Check if this line starts with a code fence
      for (const [start, end] of CODE_FENCES_SORTED_FOR_SUBSTRINGS) {
        // For backtick-style code blocks
        if (isMarkdownFence(start)) {
          // Check if the line starts with the fence after whitespace
          if (matchesAt(line, leadingSpaces, start, false)) {
            // flush the content of the non-code block
            this.appendLine(line.slice(0, leadingSpaces), false, true);
            this.flushBlock(false, true);

            const afterStart = line.slice(leadingSpaces + start.length).trim();
            this.activeFence = [start, end];
            this.lang = afterStart?.length ? afterStart : undefined;
            this.content = '';
            return;
          }
        } else if (isXmlFence(start) && line.includes(start)) {
          // For HTML-style code blocks can start anywhere
          const startIndex = line.indexOf(start);
          const afterStart = line.slice(startIndex + start.length);
          const endIndex = afterStart.indexOf(end);
          // flush the content of the non-code block
          this.appendLine(line.slice(0, startIndex), false, true);
          this.flushBlock(false, true);

          if (endIndex >= 0) {
            // Single-line HTML code block
            this.callback(afterStart.slice(0, endIndex), true, undefined, true);
          } else {
            // Multi-line HTML code block
            this.activeFence = [start, end];
            this.lang = undefined;
            this.appendLine(afterStart, true, isLastLine);
          }
          return;
        }
      }
      // record non-code block content
      this.appendLine(line, false, isLastLine);
    } else if (isMarkdownFence(this.activeFence[0])) {
      // Inside a backtick code block

      // Check if this is a closing fence - it matches AND there's nothing after
      if (matchesAt(line, leadingSpaces, this.activeFence[1], true)) {
        this.flushBlock(true, true);
      } else {
        // Regular line inside backtick code block
        this.appendLine(line, false, isLastLine);
      }
    } else if (isXmlFence(this.activeFence[0])) {
      // Inside HTML-style code block
      const closeIndex = line.indexOf(this.activeFence[1]);

      if (closeIndex >= 0) {
        // Add content up to the closing tag
        this.content += line.slice(0, closeIndex);

        // Save before resetting so we avoid side effects from callback
        const remaining = line.slice(closeIndex + this.activeFence[1].length);
        this.flushBlock(true, true);

        // Process anything after the closing tag
        if (remaining) {
          this.processLine(remaining, leadingSpaces, isLastLine);
        }
      } else {
        // Add the whole line with newline
        this.appendLine(line, false, isLastLine);
      }
    }
  }

  appendLine(line: string, restartContent: boolean, isLastLine: boolean) {
    if (restartContent) {
      this.content = line;
    } else {
      this.content += line;
    }
    if (!isLastLine) this.content += '\n';
  }

  feed(chunk: string) {
    for (const char of chunk) {
      if (char === '\n') {
        // Process the current line
        this.processLine(this.lineBuffer, this.leadingSpaces, false);
        this.lineBuffer = '';
        this.isLineStart = true;
        this.leadingSpaces = 0;
      } else {
        // Add character to line buffer
        this.lineBuffer += char;

        if (this.isLineStart) {
          if (char === ' ' || char === '\t') {
            this.leadingSpaces++;
          } else {
            this.isLineStart = false;
          }
        }
      }
    }
  }

  end() {
    // Process final line if there is one
    if (this.lineBuffer) {
      this.processLine(this.lineBuffer, this.leadingSpaces, true);
    }

    // Handle unclosed blocks
    this.flushBlock(this.activeFence != null, false);
  }
}

// simple interface for handling a complete text in one shot
export function parseCodeBlocks<T>(text: string, callback: CodeBlockParserCallback<T>): [number, T[]] {
  const parser = new CodeBlockParser(callback);
  parser.feed(text);
  parser.end();
  return [parser.getCodeBlocksCount(), parser.getResults()];
}
